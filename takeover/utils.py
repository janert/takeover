
import pyglet

# Usage:
# Override draw() for display; also any evt handlers you need.
# Any built-in handlers will be called after the handlers on this object.
# Return pyglet.event.EVENT_HANDLED (==True) to prevent forwarding!
#
# The purpose of a Controller is to encapsulate each "level" or "screen"
# of a game. It can be swapped into the window, which handles the display.
#
# As is, this class also serves to document the set of events that are
# generated by window, as long as they are of any relevance to me...
class Controller:
    # Display
    def draw(self): pass
    # def on_draw(self): self.draw()
    # def on_expose(self): self.draw()
    
    # Window visibility, kbd focus and lifecycle
    def on_show(self): pass
    def on_hide(self): pass
    def on_move(self, x, y): pass
    def on_resize(self, width, height): pass
    def on_activate(self): pass
    def on_deactivate(self): pass
    def on_close(self): pass
    
    # Keybd evts
    def on_key_press(self, sym, mod): pass
    def on_key_release(self, sym, mod): pass

    # Mouse evts
    def on_mouse_enter(self, x, y): pass
    def on_mouse_leave(self, x, y): pass
    
    def on_mouse_motion(self, x, y, dx, dy): pass
    def on_mouse_press( self, x, y, but, mod): pass
    def on_mouse_release( self, x, y, but, mod): pass
    def on_mouse_drag(self, x, y, dx, dy, but, mod): pass
    # def on_mouse_scroll(x, y, fx, fy): pass
                        
    # Text evts
    def on_text(self, text): pass
    def on_text_motion(self, mov): pass
   
    
# Usage:
# Use as application window, providing handler
#
# NOTE: only a subset of window events is being handled!!!
class MainWindow( pyglet.window.Window ):
    def __init__( self, *args, **kwargs ):
        super().__init__( *args, **kwargs )
        self.controller = None
        
    # Default impls, w/o controller
    def on_expose( self ):
        self.on_draw()
        
    def on_draw( self ):
        self.clear()
        pyglet.shapes.Rectangle( 0, 0, self.width, self.height,
                                 color=(255,255,255) ).draw()
        
    def set_controller( self, controller ):
        # print( "Before", self._event_stack, len(self._event_stack) )
        
        # If a prev controller has been set, remove its event handling
        if self.controller is not None:
            # self.pop_handlers()
            pass
            
        # Keep a reference to prevent garbage collection
        self.controller = controller

        # Display: completely replace default evt handlers
        self.on_draw = controller.draw
        self.on_expose = controller.draw

        # This leaves built-in evt handlers in place,
        # return pyglet.event.EVENT_HANDLED (==True) to prevent forwarding
        self.push_handlers( controller )

        """
        self.push_handlers( controller.on_key_press,
                            controller.on_key_release,
                            controller.on_mouse_press,
                            controller.on_mouse_release,
                            controller.on_mouse_motion,
                            controller.on_mouse_drag )
        """

        
# PushButton that also emits on_enter and on_leave.
# Also, convenience method to rescale image
class HoverButton( pyglet.gui.PushButton ):
    def __init__( self, *args, **kwargs ):
        super().__init__( *args, **kwargs )
        
        self._inside = False

        self._click_down = False
        
    def set_scale( self, scale1, scale2=None ):
        if scale2:
            self._sprite.update( scale_x=scale1, scale_y=scale2 )
        else:
            self._sprite.update( scale=scale1 )

        self._width = self._sprite.width
        self._height =self._sprite.height

    def on_mouse_press( self, x, y, buttons, modifiers ):
        if not self.enabled or not self._check_hit(x, y):
            return
        
        self._click_down = True

        # Let the base class handle the image change
        return super().on_mouse_press( x, y, buttons, modifiers )

    def on_mouse_release( self, x, y, buttons, modifiers ):
        if not self.enabled:
            return

        # Only emit on_click if prev clicked inside and now released inside
        if self._click_down and self._check_hit( x, y ):
            self.dispatch_event( "on_click" )
            
        # Release always cancels click_down...
        self._click_down = False
            
        # Let base class handle images
        return super().on_mouse_release( x, y, buttons, modifiers )

    def on_mouse_motion( self, x, y, dx, dy ):
        if not self.enabled:
            return
        
        if self._inside == False and self._check_hit( x, y ) == True:
            self._inside = True
            self.dispatch_event( "on_enter" )
            
        elif self._inside == True and self._check_hit( x, y ) == False:
            self._inside = False
            self.dispatch_event( "on_leave" )

        # Let base clase handle images
        super().on_mouse_motion( x, y, dx, dy )

    def on_mouse_drag( self, x, y, dx, dy, but, mod ):
        if not self.enabled:
            return
        
        if self._inside == False and self._check_hit( x, y ) == True:
            self._inside = True
            self._sprite.image = self._pressed_img            
            self.dispatch_event( "on_enter" ) # , x, y, dx, dy, but, mod )
            
        elif self._inside == True and self._check_hit( x, y ) == False:
            self._inside = False
            self._sprite.image = self._depressed_img            
            self.dispatch_event( "on_leave" ) # , x, y, dx, dy, but, mod )

        # Do not call super. I disagree with pyglet's image handling:
        # I want the img to switch to hover, even if clicked earlier outside.
        # (One can argue about that.)
        
HoverButton.register_event_type( "on_click" )    
HoverButton.register_event_type( "on_enter" )
HoverButton.register_event_type( "on_leave" )


# ************************************************************
# 
# VERY IMPORTANT NOTE:
#
# Widgets ONLY receive events if mouse is in frame bucket holding the widget.
# If the widget is right up to the edge, it is possible that the widget may
# not handle mouse-leave properly: the last event received was inside the
# bucket and inside the widget. To recognize mouse-leave, the widget next
# needs to receive a mouse event OUTSIDE the widget. But if the next widget
# is right up to the bucket boundary, it may not receive ANY next event at
# all, and hence not recognize the mouse-leave event sequence from occurring.
#
# The easy remedy is to make sure there is only one bucket in the frame.
# This way, each widget receives ALL events, always. (Of course, this makes
# the frame pointless, but so be it.) In other words, the bucket size must
# be greater than max(win.wid, win.hgt)!
#
# The Frame class below does this automatically.
#
# ************************************************************


# ************************************************************
# 
# SECOND VERY IMPORTANT NOTE:
#
# Frames push themselves onto the event handler stack in their ctor.
# (This seems to be undocumented.)
# Beware when popping handlers off of the stack: you might be popping a frame.
#
# ************************************************************

class Frame( pyglet.gui.Frame ):
    def __init__( self, window, *args, **kwargs ):
        super().__init__( window, cell_size=max(window.width, window.height),
                          *args, **kwargs )


# Slider with title and text display of chosen value. Values are ints !!!
class LabeledSlider( pyglet.gui.Slider ):
    def __init__( self, *args, **kwargs ):
        super().__init__( *args, **kwargs )

        fonts, fontsize = None, 10

        """
        # Original version, title and value centered above and below bar

        self.label1 = pyglet.text.Label( "", 
                                         x=self.x + self.width//2,
                                         y=self.y + 30,
                                         anchor_x='center', anchor_y='baseline',
                                         color=(0,0,0,255),
                                         font_name=fonts, font_size=fontsize,
                                         batch=kwargs["batch"] )

        self.label2 = pyglet.text.Label( "", 
                                         x=self.x + self.width//2,
                                         y=self.y + 0,
                                         anchor_x='center', anchor_y='baseline',
                                         color=(0,0,0,255),
                                         font_name=fonts, font_size=fontsize,
                                         batch=kwargs["batch"] )
        """

        # New version, metallic design, title and value flush left/right
        self.label1 = pyglet.text.Label( "", 
                                         x=self.x + self.width//8,
                                         y=self.y + self.height//2-2,
                                         anchor_x='left', anchor_y='baseline',
                                         color=(255,255,255,255),
                                         font_name=fonts, font_size=fontsize,
                                         batch=kwargs["batch"] )
        
        
        self.label2 = pyglet.text.Label( "", 
                                         x=self.x + 7*self.width/8,
                                         y=self.y + self.height//2-2,
                                         anchor_x='right', anchor_y='baseline',
                                         color=(255,0,0,255),
                                         font_name=fonts, font_size=fontsize,
                                         batch=kwargs["batch"] )

    def update( self, title, val, min_val, max_val ):
        self.label1.text = title

        self.f = lambda val: int( min_val + 0.01*val*(max_val-min_val) )

        self.value = 0
        if max_val > min_val:
            self.value = 100*(val-min_val)/(max_val-min_val)
        self.result = val
        self.label2.text = str( self.result )
        
    def on_change( self, val ):
        self.result = self.f( val )
        self.label2.text = str( self.result )
        # does this still dispatch an on_change event or must I call super?
        
    def on_mouse_release(self, x, y, buttons, modifiers):
        # if not self._check_hit( x, y ):
        #    return
        
        self.dispatch_event( "on_up", self.result )
        super().on_mouse_release( x, y, buttons, modifiers )
        
LabeledSlider.register_event_type( "on_up" )
        

# A block of widgets that can be translated as a whole by setting the coords
# of the block's lower-left corner.
# It is assumed that all widgets have a position relative to (0,0); they will
# be translated.
# Widgets are expected to have .x, .y, and .batch members.
# This means currently only Sprites; shapes and labels have no batch members!
#
# This is a bit of a hack... the widgets will be irrevocably modified.
# You can't reset the position of the layout after its creation (because
# that would move all widgets again).
#
# Really, this is a concept class. Get rid of it eventually (or finish)
# Currently unused...
class Layout:
    def __init__( self, x, y ):
        self.batch = pyglet.graphics.Batch()
        self.x, self.y = x, y
        self.widgets = []
        
    def draw( self ):
        self.batch.draw()
        
    def add_widget( self, widget ):
        widget.x += self.x
        widget.y += self.y
        widget.batch = self.batch
        self.widgets.append(widget)

        
# A table of text labels.
# Colspec is an array of integers representing column widths in pixels.
# The entire table can be moved into position as a whole.
# The text of each label can be changed, as can be the color and bold/italic.
# It is also possible to replace individual entries w/ sprites.
#
# It would be nice to also support alignment (such as ["10c", "20r", ...]),
# or fractional/percentage col widths. This is currently NOT implemented.
#
# Anchor: "left", "center", "right"; "bottom", "center", "top", "baseline"
class TextTable():
    def __init__( self, lines, linehgt, colspec,
                  background=(220,220,220), fonts=None, fontsize=None ):
        self.batch = pyglet.graphics.Batch()

        self.x, self.y = 0, 0

        self.width = sum(colspec)
        self.height = lines*linehgt

        self.cols = len(colspec)

        self.highlighted = None
        
        self.labels = []
        for i in range(lines):
            pos = 0
            for j in range(self.cols):
                lab = pyglet.text.Label( "%d:%d" % (i,j),
                                         x=pos, y=(lines-i-1)*linehgt,
                                         anchor_x="left", anchor_y="bottom",
                                         color=(0,0,0,255),
                                         font_name=fonts, font_size=fontsize,
                                         batch=self.batch )
                pos += colspec[j]
                self.labels.append(lab)

        self.bgs = []
        for i in range(lines):
            if i%2 == 0:
                color = ( 255, 255, 255 )
            else:
                color = background
                
            bg = pyglet.shapes.Rectangle( self.x, (lines-i-1)*linehgt,
                                          self.width, linehgt,
                                          color=color,
                                          batch=self.batch)
            self.bgs.append( bg )

        self.highlighted = [ None ] * lines
        
    # Location of bottom left corner
    def set_position( self, x, y ):        
        for i in range( len(self.labels) ):
            self.labels[i].x -= self.x
            self.labels[i].y -= self.y

        for i in range( len(self.bgs) ):
            self.bgs[i].x -= self.x
            self.bgs[i].y -= self.y

        self.x = x
        self.y = y
            
        for i in range( len(self.labels) ):
            self.labels[i].x += self.x
            self.labels[i].y += self.y

        for i in range( len(self.bgs) ):            
            self.bgs[i].x += self.x
            self.bgs[i].y += self.y            

    # row is top->down, col is left->right, both zero indexed!
    def set_text( self, row, col, text ):
        self.labels[ row*self.cols + col ].text = text
    
    def set_attr( self, row, col, text=None,
                  color=(0,0,0,255), bold=False, italic=False, size=None ):
        k = row*self.cols + col
        
        if text is not None: self.labels[k].text = text
        self.labels[k].color = color
        self.labels[k].bold = bold
        self.labels[k].italic = italic
        if size is not None: self.labels[k].font_size = size

    # Possible to replace individual labels with sprites at the same location
    def set_sprite( self, row, col, sprite ):
        k = row*self.cols + col

        self.labels[k].text = ""
        
        sprite.x = self.labels[k].x
        sprite.y = self.labels[k].y
        sprite.batch = self.labels[k].batch
        
        self.labels[k] = sprite

    # Toggle switch
    # (255,255,0) yellow; (255,253,1) bright
    # (253,238,0) aureolin; (255,239,0) canary; (255,240,0) yellow rose
    # (255,255,51) electric; (255,253,55) sunshine
    def highlight( self, row ):
        if self.highlighted[row] is None:
            self.highlighted[row] = self.bgs[row].color
            self.bgs[row].color = (255,230,0)
        else:
            self.bgs[row].color = self.highlighted[row]
            self.highlighted[row] = None
        
    def draw( self ):
#        self.bg = pyglet.shapes.Rectangle( self.x, self.y,
#                                           self.width, self.height,
#                                           color=(220,220,220) ).draw()        
        
        self.batch.draw()
        

if __name__ == "__main__":
    win = MainWindow()
    win.t = TextTable( 3, 20, [ 30, 40, 20 ], fontsize=10 )
    win.t.set_text( 0, 0, "foo" )
    win.t.set_attr( 1, 1, color=(255,0,0,255) )
    win.t.set_position( 100, 20 )

    pyglet.resource.path = [ "img/gif" ]
    s = pyglet.resource.image( "smsaturn-icon.gif" )
    s.anchor_x, s.anchor_y = s.width//4, s.height//4
    s = pyglet.sprite.Sprite( s )

    win.t.set_sprite( 1, 2, s )

    
    pyglet.app.run()


    
